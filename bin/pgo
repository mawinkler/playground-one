#!/usr/bin/env bash

bold=$(tput bold)
normal=$(tput sgr0)
yellow=$(tput setaf 3)
blue=$(tput setaf 4)
red=$(tput setaf 1)
green=$(tput setaf 2)

# Test internet connectivity
ping -c 1 -w 3 8.8.8.8 &> /dev/null
if [[ $? > 0 ]] ; then
  printf '%s\n' "${bold}${red}!!! No network connection !!!${normal}"
  sleep 3
  exit 0
fi

set -e

export DEBIAN_FRONTEND=noninteractive

[ -f $ONEPATH/banner.txt ] && cat $ONEPATH/banner.txt

# Source helpers
if [ -f $ONEPATH/bin/playground-helpers.sh ]; then
  .  $ONEPATH/bin/playground-helpers.sh
else
  curl -fsSL https://raw.githubusercontent.com/mawinkler/playground-one/main/bin/playground-helpers.sh -o /tmp/playground-helpers.sh
  . /tmp/playground-helpers.sh
fi

# Check for dialog
if is_linux; then
  DIALOG_INSTALLED=$(apt -qq list dialog 2>/dev/null)
  if [[ "$DIALOG_INSTALLED" != *"installed"* ]]; then
    sudo apt update
    sudo apt install -y dialog
  fi
fi

# Bootstrap
if [ ! -f "$ONEPATH/.pghome" ]; then
  curl -fsSL https://raw.githubusercontent.com/mawinkler/playground-one/main/bin/bootstrap.sh -o /tmp/bootstrap.sh
  . /tmp/bootstrap.sh $(pwd)

  touch /tmp/bootstrap_done
  # exit 0
fi

#######################################
# Configuration Map
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   configs
#######################################
# declare -A configs=$(< ${ONEPATH}/bin/.configs)  # problematic with pgoc and px since we'd need the file there
declare -A configs
configs=(
  ["all"]=${ONEPATH}
  ["user"]=${ONEPATH}/awsone/1-pgo-user
  ["satellite"]=${ONEPATH}/awsone/1-pgo-satellite
  ["network"]=${ONEPATH}/awsone/2-network
  ["network-retrieve"]=${ONEPATH}/awsone/2-network
  ["network-delete"]=${ONEPATH}/awsone/2-network
  ["nw"]=${ONEPATH}/awsone/2-network
  ["nw-retrieve"]=${ONEPATH}/awsone/2-network
  ["nw-delete"]=${ONEPATH}/awsone/2-network
  ["ec2"]=${ONEPATH}/awsone/3-instances
  ["instances"]=${ONEPATH}/awsone/3-instances
  ["testlab-cs"]=${ONEPATH}/awsone/3-testlab-cs
  ["testlab-cs-retrieve"]=${ONEPATH}/awsone/3-testlab-cs
  ["testlab-cs-delete"]=${ONEPATH}/awsone/3-testlab-cs
  ["eks"]=${ONEPATH}/awsone/4-cluster-eks-ec2
  ["eks-ec2"]=${ONEPATH}/awsone/4-cluster-eks-ec2
  ["eks-ec2-deployments"]=${ONEPATH}/awsone/8-cluster-eks-ec2-deployments
  ["eks-fg"]=${ONEPATH}/awsone/4-cluster-eks-fargate
  ["eks-fg-deployments"]=${ONEPATH}/awsone/8-cluster-eks-fargate-deployments
  ["aks"]=${ONEPATH}/azone/4-cluster-aks
  ["aks-deployments"]=${ONEPATH}/azone/8-cluster-aks-deployments
  ["ecs-ec2"]=${ONEPATH}/awsone/5-cluster-ecs-ec2
  ["ecs-fg"]=${ONEPATH}/awsone/5-cluster-ecs-fargate
  ["bucketscanner"]=${ONEPATH}/awsone/6-bucket-scanner
  ["scenarios-cloudtrail"]=${ONEPATH}/awsone/7-scenarios-cloudtrail
  ["scenarios-cspm"]=${ONEPATH}/awsone/7-scenarios-cspm
  ["scenarios-data"]=${ONEPATH}/awsone/7-scenarios-data
  ["scenarios"]=${ONEPATH}/awsone/7-scenarios-ec2
  ["scenarios-ec2"]=${ONEPATH}/awsone/7-scenarios-ec2
  ["scenarios-fg"]=${ONEPATH}/awsone/7-scenarios-fargate
  ["scenarios-identity"]=${ONEPATH}/awsone/7-scenarios-identity
  ["scenarios-zerotrust"]=${ONEPATH}/awsone/7-scenarios-zerotrust
  ["scenarios-aks"]=${ONEPATH}/azone/7-scenarios-aks
  ["goat"]=${ONEPATH}/awsone/7-goat
  ["deepsecurity"]=${ONEPATH}/awsone/9-deep-security
  ["dsm"]=${ONEPATH}/awsone/9-deep-security
  ["dsw"]=${ONEPATH}/awsone/9-deep-security-workload
  ["wsw"]=${ONEPATH}/awsone/9-workload-security-workload
  ["kind"]=${ONEPATH}/kindone/4-cluster-kind
  ["scenarios-kind"]=${ONEPATH}/kindone/7-scenarios-kind
  ["kind-deployments"]=${ONEPATH}/kindone/8-cluster-kind-deployments
)

#######################################
# Run a Terraform apply and destroy as
# plan only
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
dryrun=False

#######################################
# Set KUBE_CONFIG_PATH to default
# config
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
# export KUBE_CONFIG_PATH=~/.kube/config

#######################################
# Run a Terraform action
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name
#   Terraform action
# Outputs:
#   None
#######################################
function tf() {
  config=$1
  action=$2

  printf '%s\n' "Configuration ${config} in directory ${configs[$config]}"
  case "$action" in
    init)
      # terraform -chdir=${configs[$config]} init
      terraform -chdir=${configs[$config]} init --upgrade
      # versions ${configs[$config]}
      ;;
    apply)
      if [ "${dryrun}" == "True" ] ; then
        # AWS_ACCESS_KEY_ID=${aws_pgo_user_access_key} \
        #   AWS_SECRET_ACCESS_KEY=${aws_pgo_user_secret_key} \
          terraform -chdir=${configs[$config]} plan -out=${ONEPATH}/${config}.out
      else
        lock $config
        # AWS_ACCESS_KEY_ID=${aws_pgo_user_access_key} \
        #   AWS_SECRET_ACCESS_KEY=${aws_pgo_user_secret_key} \
          terraform -chdir=${configs[$config]} apply -auto-approve
      fi
      ;;
    destroy)
      if checklock $config ; then
      if [ "${dryrun}" == "True" ] ; then
        # AWS_ACCESS_KEY_ID=${aws_pgo_user_access_key} \
        #   AWS_SECRET_ACCESS_KEY=${aws_pgo_user_secret_key} \
          terraform -chdir=${configs[$config]} plan -out=${ONEPATH}/${config}.out
      else
        # AWS_ACCESS_KEY_ID=${aws_pgo_user_access_key} \
        #   AWS_SECRET_ACCESS_KEY=${aws_pgo_user_secret_key} \
          terraform -chdir=${configs[$config]} destroy -auto-approve
        unlock $config
      fi
      else
        printf '%s\n' "Configuration ${config} not applied"
      fi
      ;;
    output)
      if checklock $config ; then
        terraform -chdir=${configs[$config]} output
      else
        printf '%s\n' "Configuration ${config} not applied"
      fi
      ;;
    state)
      terraform -chdir=${configs[$config]} state list
      ;;
    show)
      terraform -chdir=${configs[$config]} show
      ;;
    validate)
      terraform -chdir=${configs[$config]} validate
      ;;
    erase)
      cd "${configs[$config]}"
      rm -rf .terraform
      rm -f .terraform.lock.hcl
      rm -f terraform.tfstate*
      unlock $config
      ;;
  esac
}

#######################################
# Lock, unlock and check lock
# a configuration
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name
# Outputs:
#   None
#######################################
function lock() {
  config=$1

  touch ${ONEPATH}/.pgo.$config.lock
}

function unlock() {
  config=$1

  rm -f ${ONEPATH}/.pgo.$config.lock
}

function checklock() {
  config=$1

  if [[ -f ${ONEPATH}/.pgo.$config.lock ]] ; then
    return
  fi
  false
}

#######################################
# Check if XDR for Containers (legacy)
# is deployed
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   None
#######################################
function check_xdr_for_containers() {

  # Checking if XDR for Containers is deployed
  # cd "${configs[network]}"
  tf_state_vpc=$(terraform -chdir=${configs[network]} state list 2>/dev/null | grep "module.vpc.aws_vpc.vpc")
  if [[ ! -z "${tf_state_vpc}" ]] ; then
    vpc_id=$(terraform -chdir=${configs[network]} output -raw vpc_id)
    subnets_createdby=$(aws ec2 describe-subnets --region ${aws_region} | \
      jq -r --arg vpc_id "$vpc_id" '.Subnets[] |
        select(.VpcId==$vpc_id) | .Tags[] | select(.Key=="CreatedBy") | .Value' | head -n1)
    if [ "${subnets_createdby}" == "VisionOneXdrForContainer" ] ; then
      printf '%s\n' "XDR for Containers is deployed in VPC ${vpc_id}"
      return
    else
      printf '%s\n' "XDR for Containers is NOT deployed in VPC ${vpc_id}"
    fi
  fi
  false
}

#######################################
# Check VPC
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   None
#######################################
function check_network() {

  # Checking if XDR for Containers is deployed and update tfvars
  # if check_xdr_for_containers ; then
  #   xdr_for_containers=true
  # else
  #   xdr_for_containers=false
  # fi
  # aws_region=${aws_region} \
  # environment_name=${environment_name} \
  # pgo_access_ip=${pgo_access_ip} \
  # xdr_for_containers=${xdr_for_containers} \
  # ONEPATH=${ONEPATH} \
  #   envsubst <$ONEPATH/templates/terraform-2-network.tfvars >${configs[network]}/terraform.tfvars

  # Check locks
  for config in instances testlab-cs eks-ec2 eks-fg ecs-ec2 ecs-fg scenarios-identity scenarios-zerotrust; do
    # init ${config}
    if checklock ${config} ; then
      printf 'Destroy %s configuration first\n' "${config}"
      exit 0
    fi
  done
}

#######################################
# Initializes Terraform and creates
# variables.tfvars
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function init() {

  telemetry "init" $1

  case $1 in
    user|all)
      printf '%s\n' "Create terraform.tfvars for PGO user"
      aws_region=${aws_region} \
      aws_account_id=${aws_account_id} \
      environment_name=${environment_name} \
        envsubst <$ONEPATH/templates/terraform-1-pgo-user.tfvars >${configs[user]}/terraform.tfvars
      
      [ "$2" = "" ] && tf user init
      ;;&
    satellite|all)
      printf '%s\n' "Create terraform.tfvars for PGO satellite"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name="pgo-satellite-"${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-1-pgo-satellite.tfvars >${configs[satellite]}/terraform.tfvars
      
      [ "$2" = "" ] && tf satellite init
      ;;&
    nw|network|all)
      printf '%s\n' "Create terraform.tfvars for network"
      # if check_xdr_for_containers ; then
      #   xdr_for_containers=true
      # else
      #   xdr_for_containers=false
      # fi
      # xdr_for_containers=${xdr_for_containers} \
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      vpn_gateway=${pgo_vpn_gateway} \
      active_directory=${pgo_active_directory} \
      managed_active_directory=${pgo_managed_active_directory} \
      service_gateway=${pgo_service_gateway} \
      pgo_virtual_network_sensor_enabled=${pgo_virtual_network_sensor_enabled} \
      pgo_virtual_network_sensor_token=${pgo_virtual_network_sensor_token} \
      pgo_deep_discovery_inspector_enabled=${pgo_deep_discovery_inspector_enabled} \
      ami_active_directory_dc=${ami_active_directory_dc} \
      ami_active_directory_ca=${ami_active_directory_ca} \
      ami_service_gateway=${ami_service_gateway} \
      ami_deep_discovery_inspector=${ami_deep_discovery_inspector} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-2-network.tfvars >${configs[network]}/terraform.tfvars
      
      [ "$2" = "" ] && tf network init
      ;;&
    ec2|instances|all)
      printf '%s\n' "Create terraform.tfvars for instances"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      pgo_access_ip=${pgo_access_ip} \
      vpn_gateway=${pgo_vpn_gateway} \
      environment_name=${environment_name} \
      vision_one_asrm_create_attackpath=${vision_one_asrm_create_attackpath} \
      active_directory=${pgo_active_directory} \
      pgo_virtual_network_sensor_enabled=${pgo_virtual_network_sensor_enabled} \
      pgo_deep_discovery_inspector_enabled=${pgo_deep_discovery_inspector_enabled} \
      vision_one_endpoint_enabled=${vision_one_endpoint_enabled} \
      vision_one_endpoint_type=${vision_one_endpoint_type} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-3-instances.tfvars >${configs[instances]}/terraform.tfvars

      [ "$2" = "" ] && tf instances init
      ;;&
    testlab-cs|all)
      printf '%s\n' "Create terraform.tfvars for testlab-cs"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      pgo_access_ip=${pgo_access_ip} \
      environment_name=${environment_name} \
      vision_one_asrm_create_attackpath=${vision_one_asrm_create_attackpath} \
      active_directory=${pgo_active_directory} \
      pgo_virtual_network_sensor_enabled=${pgo_virtual_network_sensor_enabled} \
      pgo_deep_discovery_inspector_enabled=${pgo_deep_discovery_inspector_enabled} \
      vision_one_endpoint_enabled=${vision_one_endpoint_enabled} \
      vision_one_endpoint_type=${vision_one_endpoint_type} \
      deep_security_license=${deep_security_license} \
      deep_security_username=${deep_security_username} \
      deep_security_password=${deep_security_password} \
      ami_apex_one_server=${ami_apex_one_server} \
      ami_apex_one_central=${ami_apex_one_central} \
      ami_windows_client=${ami_windows_client} \
      ami_bastion=${ami_bastion} \
      ami_dsm=${ami_dsm} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-3-testlab-cs.tfvars >${configs[testlab-cs]}/terraform.tfvars

      [ "$2" = "" ] && tf testlab-cs init
      ;;&
    eks|eks-ec2|all)
      printf '%s\n' "Create terraform.tfvars for cluster-eks-ec2"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      pgo_eks_create_ec2=${pgo_eks_create_ec2} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-4-cluster-eks-ec2.tfvars >${configs[eks-ec2]}/terraform.tfvars
      printf '%s\n' "Create terraform.tfvars for cluster-eks deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      vision_one_cs_enabled=${vision_one_cs_enabled} \
      vision_one_cs_policy=${vision_one_cs_policy} \
      vision_one_cs_policy_operator=${vision_one_cs_policy_operator} \
      vision_one_cs_group_id=${vision_one_cs_group_id} \
      vision_one_api_key=${vision_one_api_key} \
      vision_one_api_url=${vision_one_api_url} \
      vision_one_region=${vision_one_region} \
      integrations_calico_enabled=${integrations_calico_enabled} \
      integrations_prometheus_enabled=${integrations_prometheus_enabled} \
      integrations_prometheus_grafana_password=${integrations_prometheus_grafana_password} \
      integrations_trivy_enabled=${integrations_trivy_enabled} \
      integrations_istio_enabled=${integrations_istio_enabled} \
      integrations_pgoweb_enabled=${integrations_pgoweb_enabled} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-8-cluster-eks-ec2-deployments.tfvars >${configs[eks-ec2-deployments]}/terraform.tfvars

      [ "$2" = "" ] && tf eks-ec2 init
      [ "$2" = "" ] && tf eks-ec2-deployments init
      ;;&
    eks-fg|all)
      printf '%s\n' "Create terraform.tfvars for cluster-eks-fargate"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      pgo_eks_create_ec2=${pgo_eks_create_ec2} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-4-cluster-eks-fargate.tfvars >${configs[eks-fg]}/terraform.tfvars
      printf '%s\n' "Create terraform.tfvars for cluster-eks deployments"
      aws_region=${aws_region} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      vision_one_cs_enabled=${vision_one_cs_enabled} \
      vision_one_cs_policy=${vision_one_cs_policy} \
      vision_one_cs_policy_operator=${vision_one_cs_policy_operator} \
      vision_one_cs_group_id=${vision_one_cs_group_id} \
      vision_one_api_key=${vision_one_api_key} \
      vision_one_api_url=${vision_one_api_url} \
      vision_one_region=${vision_one_region} \
      integrations_calico_enabled=${integrations_calico_enabled} \
      integrations_prometheus_enabled=${integrations_prometheus_enabled} \
      integrations_prometheus_grafana_password=${integrations_prometheus_grafana_password} \
      integrations_trivy_enabled=${integrations_trivy_enabled} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-8-cluster-eks-fargate-deployments.tfvars >${configs[eks-fg-deployments]}/terraform.tfvars

      [ "$2" = "" ] && tf eks-fg init
      [ "$2" = "" ] && tf eks-fg-deployments init
      ;;&
    aks|all)
      printf '%s\n' "Create terraform.tfvars for cluster-aks"
      azure_subscription_id=${azure_subscription_id} \
      azure_region=${azure_region} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-4-cluster-aks.tfvars >${configs[aks]}/terraform.tfvars
      printf '%s\n' "Create terraform.tfvars for cluster-aks deployments"
      azure_subscription_id=${azure_subscription_id} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      vision_one_cs_enabled=${vision_one_cs_enabled} \
      vision_one_cs_policy=${vision_one_cs_policy} \
      vision_one_cs_policy_operator=${vision_one_cs_policy_operator} \
      vision_one_cs_group_id=${vision_one_cs_group_id} \
      vision_one_api_key=${vision_one_api_key} \
      vision_one_api_url=${vision_one_api_url} \
      vision_one_region=${vision_one_region} \
      integrations_calico_enabled=${integrations_calico_enabled} \
      integrations_prometheus_enabled=${integrations_prometheus_enabled} \
      integrations_prometheus_grafana_password=${integrations_prometheus_grafana_password} \
      integrations_trivy_enabled=${integrations_trivy_enabled} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-8-cluster-aks-deployments.tfvars >${configs[aks-deployments]}/terraform.tfvars

      [ "$2" = "" ] && tf aks init
      [ "$2" = "" ] && tf aks-deployments init
      ;;&
    ecs-ec2|all)
      printf '%s\n' "Create terraform.tfvars for cluster-ecs-ec2"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-5-cluster-ecs-ec2.tfvars >${configs[ecs-ec2]}/terraform.tfvars

      [ "$2" = "" ] && tf ecs-ec2 init
      ;;&
    ecs-fg|all)
      printf '%s\n' "Create terraform.tfvars for cluster-ecs-fg"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-5-cluster-ecs-fargate.tfvars >${configs[ecs-fg]}/terraform.tfvars

      [ "$2" = "" ] && tf ecs-fg init
      ;;&
    bucketscanner|all)
      printf '%s\n' "Create terraform.tfvars for bucketscanner"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      vision_one_api_key=${vision_one_api_key} \
      vision_one_region=${vision_one_region} \
      vision_one_bs_fss=${vision_one_bs_fss} \
      vision_one_bs_sandbox=${vision_one_bs_sandbox} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-6-bucket-scanner.tfvars >${configs[bucketscanner]}/terraform.tfvars

      [ "$2" = "" ] && tf bucketscanner init
      ;;&
    scenarios|scenarios-ec2|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-ec2 deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-ec2.tfvars >${configs[scenarios-ec2]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-ec2 init
      ;;&
    scenarios-fg|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-fg deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-fargate.tfvars >${configs[scenarios-fg]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-fg init
      ;;&
    scenarios-cloudtrail|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-cloudtrail deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-cloudtrail.tfvars >${configs[scenarios-cloudtrail]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-cloudtrail init
      ;;&
    scenarios-cspm|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-cspm deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-cspm.tfvars >${configs[scenarios-cspm]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-cspm init
      ;;&
    scenarios-identity|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-identity deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      active_directory=${pgo_active_directory} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-identity.tfvars >${configs[scenarios-identity]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-identity init
      ;;&
    scenarios-zerotrust|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-zerotrust deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      pgo_access_ip=${pgo_access_ip} \
      environment_name=${environment_name} \
      active_directory=${pgo_active_directory} \
      private_access_gateway=${pgo_private_access_gateway} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-zerotrust.tfvars >${configs[scenarios-zerotrust]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-zerotrust init
      ;;&
    scenarios-aks|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-aks deployments"
      azure_subscription_id=${azure_subscription_id} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-aks.tfvars >${configs[scenarios-aks]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-aks init
      ;;&
    goat|all)
      printf '%s\n' "Create terraform.tfvars for goat deployments"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip//[\[\]\" ]/} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-7-goat.tfvars >${configs[goat]}/terraform.tfvars

      [ "$2" = "" ] && tf goat init
      ;;&
    dsm|deepsecurity|all)
      printf '%s\n' "Create terraform.tfvars for deep security"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      deep_security_license=${deep_security_license} \
      deep_security_username=${deep_security_username} \
      deep_security_password=${deep_security_password} \
      px=${pgo_px} \
      service_gateway=${pgo_service_gateway} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-9-deep-security.tfvars >${configs[dsm]}/terraform.tfvars

      [ "$2" = "" ] && tf dsm init
      ;;&
    dsw|all)
      printf '%s\n' "Create terraform.tfvars for deep security workload"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      deep_security_license=${deep_security_license} \
      deep_security_username=${deep_security_username} \
      deep_security_password=${deep_security_password} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-9-deep-security-workload.tfvars >${configs[dsw]}/terraform.tfvars

      [ "$2" = "" ] && tf dsw init
      ;;&
    wsw|all)
      printf '%s\n' "Create terraform.tfvars for workload security workload"
      aws_region=${aws_region} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      environment_name=${environment_name} \
      pgo_access_ip=${pgo_access_ip} \
      workload_security_region=${workload_security_region} \
      workload_security_tenant_id=${workload_security_tenant_id} \
      workload_security_token=${workload_security_token} \
      workload_security_api_key=${workload_security_api_key} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-9-workload-security-workload.tfvars >${configs[wsw]}/terraform.tfvars

      [ "$2" = "" ] && tf wsw init
      ;;&
    kind|all)
      printf '%s\n' "Create terraform.tfvars for cluster-kind"
      environment_name=${environment_name} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-4-cluster-kind.tfvars >${configs[kind]}/terraform.tfvars

      environment_name=${environment_name} \
      aws_pgo_user_access_key=${aws_pgo_user_access_key} \
      aws_pgo_user_secret_key=${aws_pgo_user_secret_key} \
      vision_one_cs_enabled=${vision_one_cs_enabled} \
      vision_one_cs_policy=${vision_one_cs_policy} \
      vision_one_cs_policy_operator=${vision_one_cs_policy_operator} \
      vision_one_cs_group_id="00000000-0000-0000-0000-000000000000" \
      vision_one_api_key=${vision_one_api_key} \
      vision_one_api_url=${vision_one_api_url} \
      vision_one_region=${vision_one_region} \
      integrations_calico_enabled=${integrations_calico_enabled} \
      integrations_prometheus_enabled=${integrations_prometheus_enabled} \
      integrations_prometheus_grafana_password=${integrations_prometheus_grafana_password} \
      integrations_trivy_enabled=${integrations_trivy_enabled} \
      integrations_metallb_enabled=${integrations_metallb_enabled} \
      integrations_pgoweb_enabled=${integrations_pgoweb_enabled} \
      integrations_argocd_enabled=${integrations_argocd_enabled} \
      ONEPATH=${ONEPATH} \
        envsubst <$ONEPATH/templates/terraform-8-cluster-kind-deployments.tfvars >${configs[kind-deployments]}/terraform.tfvars

      [ "$2" = "" ] && tf kind init
      [ "$2" = "" ] && tf kind-deployments init
      ;;&
    scenarios-kind|all)
      printf '%s\n' "Create terraform.tfvars for scenarios-kind deployments"
      environment_name=${environment_name} \
        envsubst <$ONEPATH/templates/terraform-7-scenarios-kind.tfvars >${configs[scenarios-kind]}/terraform.tfvars

      [ "$2" = "" ] && tf scenarios-kind init
      ;;
  esac
  printf '%s\n' "💬 Terraform terraform.tfvars dropped to configurations"
}

#######################################
# Applies a Terraform configuration
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function apply() {

  telemetry "apply" $1

  case $1 in
    user)
      AWS_ACCESS_KEY_ID="" \
        AWS_SECRET_ACCESS_KEY="" \
        tf user apply
      printf '%s\n' "Saving Access Key to configuration..."
      aws_pgo_user_access_key=$(terraform -chdir=${configs[user]} output -raw access_key)
      aws_pgo_user_secret_key=$(terraform -chdir=${configs[user]} output -raw secret_key)
      target_val=${aws_pgo_user_access_key} \
        yq -i '.services.aws.pgo_user_access_key = env(target_val)' ${ONEPATH}/config.yaml
      target_val=${aws_pgo_user_secret_key} \
        yq -i '.services.aws.pgo_user_secret_key = env(target_val)' ${ONEPATH}/config.yaml
      if [ "${aws_pgo_user_enabled}" = "false" ]; then
        aws_pgo_user_access_key=""
        aws_pgo_user_secret_key=""
      fi
      init all tfvars
      ;;
    satellite|all)
      if checklock user ; then
        tf satellite apply
      else
        printf 'Apply user configuration first\n'
      fi
      ;;&
    nw|network|all)
      # check_network
      # AWS_ACCESS_KEY_ID="" \
      #   AWS_SECRET_ACCESS_KEY="" \
      if [ "${pgo_vpn_gateway}" == 'true' ]; then
        if [ ! -f ${ONEPATH}/vpn-secrets.yaml ]; then
          $ONEPATH/bin/generate-secrets.sh
        fi
      fi
      tf network apply
      if [ "${pgo_active_directory}" == 'true' ]; then
        printf '%s\n' "ad_admin_password = \"$(terraform -chdir=${configs[network]} output -raw ad_admin_password)\""
      fi
      ;;&
    ec2|instances|all)
      tf instances apply
      printf '%s\n' "win_password = \"$(terraform -chdir=${configs[instances]} output -raw win_password)\""
      printf '%s\n' "win_local_admin_password = \"$(terraform -chdir=${configs[instances]} output -raw win_local_admin_password)\""
      ;;&
    testlab-cs|all)
      tf testlab-cs apply
      printf '%s\n' "win_password = \"$(terraform -chdir=${configs[testlab-cs]} output -raw win_password)\""
      # printf '%s\n' "win_local_admin_password = \"$(terraform -chdir=${configs[testlab-cs]} output -raw win_local_admin_password)\""
      ;;&
    eks|eks-ec2|all)
      tf eks-ec2 apply
      $(terraform -chdir=${configs[eks-ec2]} output -raw update_local_context_command)
      tf eks-ec2-deployments apply
      ;;&
    eks-fg|all)
      tf eks-fg apply
      $(terraform -chdir=${configs[eks-fg]} output -raw update_local_context_command)
      tf eks-fg-deployments apply
      ;;&
    aks|all)
      tf aks apply
      # $(terraform -chdir=${configs[aks]} output -raw update_local_context_command)
      KUBECONFIG=~/.kube/config:${configs[aks]}/kubeconfig \
        kubectl config view --flatten > /tmp/config && \
        mv /tmp/config ~/.kube/config
      cluster_name=$(terraform -chdir=${configs[aks]} output -json cluster_name 2>/dev/null | jq -r .)
      if [ -n "${cluster_name}"]; then
        kubectl config use-context $(terraform -chdir=${configs[aks]} output -raw cluster_name)
      fi
      tf aks-deployments apply
      ;;&
    ecs-ec2|all)
      tf ecs-ec2 apply
      ;;&
    ecs-fg|all)
      tf ecs-fg apply
      ;;&
    bucketscanner|all)
      tf bucketscanner apply
      ;;&
    scenarios|scenarios-ec2|all)
      tf scenarios-ec2 apply
      ;;&
    scenarios-fg|all)
      tf scenarios-fg apply
      ;;&
    scenarios-cloudtrail|all)
      tf scenarios-cloudtrail apply
      ;;&
    scenarios-cspm|all)
      tf scenarios-cspm apply
      ;;&
    scenarios-identity|all)
      tf scenarios-identity apply
      ;;&
    scenarios-zerotrust|all)
      tf scenarios-zerotrust apply
      printf '%s\n' "win_local_admin_password = \"$(terraform -chdir=${configs[scenarios-zerotrust]} output -raw win_local_admin_password)\""
      ;;&
    scenarios-aks|all)
      tf scenarios-aks apply
      ;;&
    goat|all)
      tf goat apply
      ;;&
    dsm|deepsecurity|all)
      tf dsm apply
      ;;&
    dsw|all)
      tf dsw apply
      printf '%s\n' "public_instance_password_windows1 = \"$(terraform -chdir=${configs[dsw]} output -raw public_instance_password_windows1)\""
      ;;&
    wsw|all)
      tf wsw apply
      printf '%s\n' "public_instance_password_windows1 = \"$(terraform -chdir=${configs[wsw]} output -raw public_instance_password_windows1)\""
      ;;&
    kind|all)
      tf kind apply
      tf kind-deployments apply
      printf '%s\n' "argocd_admin_secret = \"$(terraform -chdir=${configs[kind-deployments]} output -raw argocd_admin_secret)\""
      ;;&
    scenarios-kind|all)
      tf scenarios-kind apply
      ;;
  esac
}

#######################################
# Updates the Access IP(s)
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   None
#######################################
function update_ip() {
  
  key_desc="Access IPs/CIDRs"
  pgo_access_ip=${pgo_access_ip//[\[\]\"]/}
  read -p "${key_desc} [${pgo_access_ip}]: " TEMP
  if [[ ! -z "${TEMP}" ]]; then
    pgo_access_ip=${TEMP}
  fi

  n='([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])'
  m='([0-9]|[12][0-9]|3[012])'
  cidr_list='['
  for cidr in $(echo ${pgo_access_ip} | tr ',' ' ')
  do
    # Input matches "pub", query public IP
    if [[ "${cidr}" == "pub" ]]; then
      cidr=$(curl -s ifconfig.me && echo)'/32'
      printf 'Public IP/CIDR %s\n' "$cidr"
    fi
    # Input matches IP, append /0 or /32
    if [[ "${cidr}" =~ ^$n(\.$n){3}$ ]]; then
      [[ "${cidr}" == "0.0.0.0" ]] && cidr='0.0.0.0/0' || cidr=$cidr'/32'
    fi
    # Test for valid CIDR
    if [[ "${cidr}" =~ ^$n(\.$n){3}/$m$ ]]; then
      cidr_list=$cidr_list'"'$cidr'",'
    else
      printf 'Error: "%s" is not a valid CIDR\n' "$cidr"
      exit 0
    fi
  done
  pgo_access_ip=${cidr_list::-1}']'
  # CIDR list correct?
  if [[ "${pgo_access_ip}" =~ ^\[\"[0-9\.\,\/\"[:space:]]+\"\]$ ]]; then
    target_val=${pgo_access_ip} \
      yq -i '.services.playground-one.access-ip = env(target_val)' ${ONEPATH}/config.yaml
  else
    echo "Error: Invalid ${key_desc} input."
    exit 0
  fi

  for config in satellite network testlab-cs eks-ec2 eks-fg aks ecs-ec2 ecs-fg scenarios-ec2 scenarios-fg scenarios-aks dsm dsw wsw; do
    init ${config}
    if checklock ${config} ; then
      apply ${config}
    fi
  done
  # TODO: Add eks deployments
}

#######################################
# Deletes computers from Deep Security
# with Playground policy assigned
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   None
#######################################
function deep_security_delete_computers() {

  # cd "${configs[dsw]}"
  dsm_url=$(terraform -chdir=${configs[dsw]} output -raw dsm_url)
  api_key=$(terraform -chdir=${configs[dsw]} output -raw ds_apikey)
  linux_policy_id=$(terraform -chdir=${configs[dsw]} output -raw linux_policy_id)
  windows_policy_id=$(terraform -chdir=${configs[dsw]} output -raw windows_policy_id)
  computer_ids=$(curl --location -ks ${dsm_url}/api/computers/search \
    --header 'api-version: v1' \
    --header 'Content-Type: application/json' \
    --header 'Accept: application/json' \
    --header 'api-secret-key: '${api_key} \
    --data '{
      "searchCriteria": [
        {
          "fieldName": "policyID",
          "numericTest": "equal",
          "numericValue": "'${linux_policy_id}'"
        }
      ]
    }' | jq -r '.computers[].ID')
  for id in ${computer_ids}; do
    printf 'Deleting Computer with ID: %s\n' "${id}"
    curl --location -ks --request DELETE ${dsm_url}/api/computers/${id} \
      --header 'api-version: v1' \
      --header 'Content-Type: application/json' \
      --header 'Accept: application/json' \
      --header 'api-secret-key: '${api_key}
  done

  computer_ids=$(curl --location -ks ${dsm_url}/api/computers/search \
    --header 'api-version: v1' \
    --header 'Content-Type: application/json' \
    --header 'Accept: application/json' \
    --header 'api-secret-key: '${api_key} \
    --data '{
      "searchCriteria": [
        {
          "fieldName": "policyID",
          "numericTest": "equal",
          "numericValue": "'${windows_policy_id}'"
        }
      ]
    }' | jq -r '.computers[].ID')
  for id in ${computer_ids}; do
    printf 'Deleting Computer with ID: %s\n' "${id}"
    curl --location -ks --request DELETE ${dsm_url}/api/computers/${id} \
      --header 'api-version: v1' \
      --header 'Content-Type: application/json' \
      --header 'Accept: application/json' \
      --header 'api-secret-key: '${api_key}
  done
}

#######################################
# Deletes computers from Workload Security
# with Playground policy assigned
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   None
#######################################
function workload_security_delete_computers() {

  # cd "${configs[wsw]}"
  wsw_url="https://workload.${workload_security_region}.cloudone.trendmicro.com"
  api_key=$(terraform -chdir=${configs[wsw]} output -raw ws_apikey)
  linux_policy_id=$(terraform -chdir=${configs[wsw]} output -raw linux_policy_id)
  windows_policy_id=$(terraform -chdir=${configs[wsw]} output -raw windows_policy_id)
  computer_ids=$(curl --location -ks ${wsw_url}/api/computers/search \
    --header 'api-version: v1' \
    --header 'Content-Type: application/json' \
    --header 'Accept: application/json' \
    --header 'api-secret-key: '${api_key} \
    --data '{
      "searchCriteria": [
        {
          "fieldName": "policyID",
          "numericTest": "equal",
          "numericValue": "'${linux_policy_id}'"
        }
      ]
    }' | jq -r '.computers[].ID')
  for id in ${computer_ids}; do
    printf 'Deleting Computer with ID: %s\n' "${id}"
    curl --location -ks --request DELETE ${wsw_url}/api/computers/${id} \
      --header 'api-version: v1' \
      --header 'Content-Type: application/json' \
      --header 'Accept: application/json' \
      --header 'api-secret-key: '${api_key}
  done

  computer_ids=$(curl --location -ks ${wsw_url}/api/computers/search \
    --header 'api-version: v1' \
    --header 'Content-Type: application/json' \
    --header 'Accept: application/json' \
    --header 'api-secret-key: '${api_key} \
    --data '{
      "searchCriteria": [
        {
          "fieldName": "policyID",
          "numericTest": "equal",
          "numericValue": "'${windows_policy_id}'"
        }
      ]
    }' | jq -r '.computers[].ID')
  for id in ${computer_ids}; do
    printf 'Deleting Computer with ID: %s\n' "${id}"
    curl --location -ks --request DELETE ${wsw_url}/api/computers/${id} \
      --header 'api-version: v1' \
      --header 'Content-Type: application/json' \
      --header 'Accept: application/json' \
      --header 'api-secret-key: '${api_key}
  done
}

#######################################
# Destroys a Terraform configuration
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function destroy() {

  telemetry "destroy" $1

  case $1 in
    user)
      if checklock user ; then
        if checklock network ; then
          printf 'Destroy network configuration first\n'
        elif checklock satellite ; then
          printf 'Destroy satellite configuration first\n'
        else
          AWS_ACCESS_KEY_ID="" \
            AWS_SECRET_ACCESS_KEY="" \
            tf user destroy
        fi
      else
        printf '%s\n' "Configuration user is not applied"
      fi
      ;;
    ec2|instances|all)
      if checklock instances ; then
        tf instances destroy
      else
        printf '%s\n' "Configuration instances is not applied"
      fi
      ;;&
    testlab-cs|all)
      if checklock testlab-cs ; then
        tf testlab-cs destroy
      else
        printf '%s\n' "Configuration testlab-cs is not applied"
      fi
      ;;&
    eks|eks-ec2|all)
      if checklock eks-ec2 ; then
        cluster_name=$(terraform -chdir=${configs[eks-ec2]} output -json cluster_name 2>/dev/null | jq -r .)
        if [ -n "${cluster_name}" ]; then
          kubectl config use-context ${cluster_name} || true  # true if cluster is somehow broken
        fi

        cluster_id=$(terraform -chdir=${configs[eks-ec2-deployments]} output -json cluster_id 2>/dev/null | jq -r .)
        if [ -z "${cluster_id}" ]; then
          printf '%s\n' "Eventually delete cluster in Vision One manually"
        else
          curl -fsSL -X DELETE \
            -H "Content-Type: application/json" \
            -H "api-version: v1" -H "Authorization: Bearer ${vision_one_api_key}" \
            "${vision_one_api_url}/v3.0/containerSecurity/kubernetesClusters/${cluster_id}"
        fi

        tf eks-ec2-deployments destroy

        if checklock scenarios-ec2 ; then
          k8s-ns-finalizer attackers
          k8s-ns-finalizer goat
          k8s-ns-finalizer victims
        fi

        tf scenarios-ec2 destroy

        tf eks-ec2 destroy

        kubectl config delete-context ${cluster_name}
      else
        printf '%s\n' "Configuration eks-ec2 is not applied"
      fi
      ;;&
    eks-fg|all)
      if checklock eks-fg ; then
        cluster_name=$(terraform -chdir=${configs[eks-fg]} output -json cluster_name 2>/dev/null | jq -r .)
        if [ -n "${cluster_name}" ]; then
          kubectl config use-context ${cluster_name} || true  # true if cluster is somehow broken
        fi

        cluster_id=$(terraform -chdir=${configs[eks-fg-deployments]} output -json cluster_id 2>/dev/null | jq -r .)
        if [ -z "${cluster_id}" ]; then
          printf '%s\n' "Eventually delete cluster in Vision One manually"
        else
          curl -fsSL -X DELETE \
            -H "Content-Type: application/json" \
            -H "api-version: v1" -H "Authorization: Bearer ${vision_one_api_key}" \
            "${vision_one_api_url}/v3.0/containerSecurity/kubernetesClusters/${cluster_id}"
        fi

        tf eks-fg-deployments destroy

        if checklock scenarios-fg ; then
          k8s-ns-finalizer attackers
        fi
        
        tf scenarios-fg destroy

        tf eks-fg destroy

        kubectl config delete-context ${cluster_name}
      else
        printf '%s\n' "Configuration eks-fg is not applied"
      fi
      ;;&
    aks|all)
      if checklock aks ; then
        cluster_name=$(terraform -chdir=${configs[aks]} output -json cluster_name 2>/dev/null | jq -r .)
        cluster_username=$(terraform -chdir=${configs[aks]} output -json cluster_username 2>/dev/null | jq -r .)
        if [ -n "${cluster_name}" ]; then
          kubectl config use-context ${cluster_name}
        fi

        tf scenarios-aks destroy

        cluster_id=$(terraform -chdir=${configs[aks-deployments]} output -json cluster_id 2>/dev/null | jq -r .)
        if [ -z "${cluster_id}" ]; then
          printf '%s\n' "Eventually delete cluster in Vision One manually"
        else
          curl -fsSL -X DELETE \
            -H "Content-Type: application/json" \
            -H "api-version: v1" -H "Authorization: Bearer ${vision_one_api_key}" \
            "${vision_one_api_url}/v3.0/containerSecurity/kubernetesClusters/${cluster_id}"
        fi

        tf aks-deployments destroy
        tf aks destroy

        if [ -n "${cluster_name}" ]; then
          kubectl config delete-context ${cluster_name}
          kubectl config delete-cluster ${cluster_name}
        fi
        if [ -n "${cluster_username}" ]; then
          kubectl config delete-user ${cluster_username}
        fi
      else
        printf '%s\n' "Configuration aks is not applied"
      fi
      ;;&
    ecs-ec2|all)
      if checklock ecs-ec2 ; then
        # Workaround for Terraform bug described in FAQ
        # Delete eventually existing autoscaling groups belonging to the ecs clusters
        asg_groups=$(aws autoscaling describe-auto-scaling-groups --region ${aws_region} | \
          jq -r --arg environment_name "$environment_name-ecs-" '.AutoScalingGroups[] | select(.AutoScalingGroupName | startswith($environment_name)) | .AutoScalingGroupName')
        for group in ${asg_groups} ; do
          printf '%s\n' "Deleting auto scaling group ${group}"
          aws autoscaling delete-auto-scaling-group --auto-scaling-group-name ${group} --region ${aws_region} --force-delete
        done
        
        # Delete eventually existing trendmicro scout service before cluster destroy
        # ecs_fargate_cluster=$(aws ecs list-clusters | jq -r --arg environment_name "$environment_name-ecs-fargate" '.clusterArns[]' | sed 's:.*/::')
        # if [[ "${ecs_fargate_cluster}" != "" ]] ; then
        #   ecs_services=$(aws ecs list-services --cluster $ecs_fargate_cluster | \
        #     jq -r --arg environment_name "$environment_name-ecs-fargate" '.serviceArns[] | select(. | endswith($environment_name) | not)' | sed 's:.*/::')
        # fi
        # for service in "${ecs_services}" ; do
        #   if [[ "${service}" != "" ]] ; then
        #     printf '%s\n' "Deleting Scout service ${service}"
        #     aws ecs delete-service --service ${service} --cluster ${ecs_fargate_cluster} --force
        #   fi
        # done

        tf ecs-ec2 destroy
      else
        printf '%s\n' "Configuration ecs-ec2 is not applied"
      fi
      ;;&
    ecs-fg|all)
      if checklock ecs-fg ; then
        # Workaround for Terraform bug described in FAQ
        # Delete eventually existing autoscaling groups belonging to the ecs clusters
        # asg_groups=$(aws autoscaling describe-auto-scaling-groups --region ${aws_region} | \
        #   jq -r --arg environment_name "$environment_name-ecs-" '.AutoScalingGroups[] | select(.AutoScalingGroupName | startswith($environment_name)) | .AutoScalingGroupName')
        # for group in ${asg_groups} ; do
        #   printf '%s\n' "Deleting auto scaling group ${group}"
        #   aws autoscaling delete-auto-scaling-group --auto-scaling-group-name ${group} --region ${aws_region} --force-delete
        # done
        
        # Delete eventually existing trendmicro scout service before cluster destroy
        # ecs_fargate_cluster=$(aws ecs list-clusters | jq -r --arg environment_name "$environment_name-ecs-fargate" '.clusterArns[]' | sed 's:.*/::')
        # if [[ "${ecs_fargate_cluster}" != "" ]] ; then
        #   ecs_services=$(aws ecs list-services --cluster $ecs_fargate_cluster | \
        #     jq -r --arg environment_name "$environment_name-ecs-fargate" '.serviceArns[] | select(. | endswith($environment_name) | not)' | sed 's:.*/::')
        # fi
        # for service in "${ecs_services}" ; do
        #   if [[ "${service}" != "" ]] ; then
        #     printf '%s\n' "Deleting Scout service ${service}"
        #     aws ecs delete-service --service ${service} --cluster ${ecs_fargate_cluster} --force
        #   fi
        # done

        tf ecs-fg destroy
      else
        printf '%s\n' "Configuration ecs-fg is not applied"
      fi
      ;;&
    bucketscanner|all)
      if checklock bucketscanner ; then
        tf bucketscanner destroy
      else
        printf '%s\n' "Configuration bucketscanner is not applied"
      fi
      ;;&
    dsw|all)
      if checklock dsw ; then
        deep_security_delete_computers
        tf dsw destroy
      else
        printf '%s\n' "Configuration dsw is not applied"
      fi
      ;;&
    wsw|all)
      if checklock wsw ; then
        workload_security_delete_computers
        tf wsw destroy
      else
        printf '%s\n' "Configuration wsw is not applied"
      fi
      ;;&
    dsm|deepsecurity|all)
      if checklock dsw ; then
        printf '%s\n' "Destroy dsw configuration first"
        exit 0
      fi
      if checklock dsm ; then
        tf dsm destroy
      else
        printf '%s\n' "Configuration dsm is not applied"
      fi
      ;;&
    satellite|all)
      if checklock satellite ; then
        tf satellite destroy
      else
        printf '%s\n' "Configuration satellite is not applied"
      fi
      ;;
    nw|network|all)
      if checklock network ; then
        check_network
        # AWS_ACCESS_KEY_ID="" \
        #   AWS_SECRET_ACCESS_KEY="" \
        tf network destroy
        rm -f $ONEPATH/vpn-secrets.yaml
      else
        printf '%s\n' "Configuration network is not applied"
      fi
      ;;
    scenarios|scenarios-ec2)
      if checklock scenarios-ec2 ; then
        tf scenarios-ec2 destroy
      else
        printf '%s\n' "Configuration scenarios-ec2 is not applied"
      fi
      ;;
    scenarios-fg)
      if checklock scenarios-fg ; then
        tf scenarios-fg destroy
      else
        printf '%s\n' "Configuration scenarios-fg is not applied"
      fi
      ;;
    scenarios-cloudtrail)
      if checklock scenarios-cloudtrail ; then
        tf scenarios-cloudtrail destroy
      else
        printf '%s\n' "Configuration scenarios-cloudtrail is not applied"
      fi
      ;;
    scenarios-cspm)
      if checklock scenarios-cspm ; then
        tf scenarios-cspm destroy
      else
        printf '%s\n' "Configuration scenarios-cspm is not applied"
      fi
      ;;
    scenarios-identity)
      if checklock scenarios-identity ; then
        tf scenarios-identity destroy
      else
        printf '%s\n' "Configuration scenarios-identity is not applied"
      fi
      ;;
    scenarios-zerotrust)
      if checklock scenarios-zerotrust ; then
        tf scenarios-zerotrust destroy
      else
        printf '%s\n' "Configuration scenarios-zerotrust is not applied"
      fi
      ;;
    scenarios-aks)
      if checklock scenarios-aks ; then
        tf scenarios-aks destroy
      else
        printf '%s\n' "Configuration scenarios-aks is not applied"
      fi
      ;;
    goat)
      if checklock goat ; then
        tf goat destroy
      else
        printf '%s\n' "Configuration goat is not applied"
      fi
      ;;&
    kind)
      if checklock kind ; then
        cluster_id=$(terraform -chdir=${configs[kind-deployments]} output -json cluster_id 2>/dev/null | jq -r .)
        if [ -z "${cluster_id}" ]; then
          printf '%s\n' "Eventually delete cluster in Vision One manually"
        else
          curl -fsSL -X DELETE \
            -H "Content-Type: application/json" \
            -H "api-version: v1" -H "Authorization: Bearer ${vision_one_api_key}" \
            "${vision_one_api_url}/v3.0/containerSecurity/kubernetesClusters/${cluster_id}"
        fi

        if checklock scenarios-kind ; then
          k8s-ns-finalizer attackers
        fi

        tf scenarios-kind destroy

        tf kind-deployments destroy

        tf kind destroy
      else
        printf '%s\n' "Configuration kind is not applied"
      fi
      ;;
    scenarios-kind)
      if checklock scenarios-kind ; then
        tf scenarios-kind destroy
      else
        printf '%s\n' "Configuration scenarios-kind is not applied"
      fi
      ;;
  esac
}

#######################################
# Lists Terraform outputs
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function output() {

  telemetry "output" $1

  case $1 in
    user|all)
      tf user output
      if checklock user ; then
        printf '%s\n' "secret_key = $(terraform -chdir=${configs[user]} output -raw secret_key)"
      fi
      ;;&
    satellite|all)
      tf satellite output
      ;;&
    nw|network|all)
      tf network output
      if [ "${pgo_managed_active_directory}" == 'true' ]; then
        printf '%s\n' "mad_admin_password = $(terraform -chdir=${configs[network]} output -raw mad_admin_password)"
      fi
      if [ "${pgo_active_directory}" == 'true' ]; then
        printf '%s\n' "ad_admin_password = $(terraform -chdir=${configs[network]} output -raw ad_admin_password)"
      fi
      ;;&
    ec2|instances|all)
      tf instances output
      printf '%s\n' "win_password = \"$(terraform -chdir=${configs[instances]} output -raw win_password)\""
      printf '%s\n' "win_local_admin_password = \"$(terraform -chdir=${configs[instances]} output -raw win_local_admin_password)\""
      ;;&
    testlab-cs|all)
      tf testlab-cs output
      printf '%s\n' "win_password = \"$(terraform -chdir=${configs[testlab-cs]} output -raw win_password)\""
      # printf '%s\n' "win_local_admin_password = \"$(terraform -chdir=${configs[testlab-cs]} output -raw win_local_admin_password)\""
      ;;&
    eks|eks-ec2|all)
      tf eks-ec2 output
      tf eks-ec2-deployments output
      ;;&
    eks-fg|all)
      tf eks-fg output
      ;;&
    aks|all)
      tf aks output
      tf aks-deployments output
      ;;&
    ecs-ec2|all)
      tf ecs-ec2 output
      ;;&
    ecs-fg|all)
      tf ecs-fg output
      ;;&
    bucketscanner|all)
      tf bucketscanner output
      ;;&
    scenarios|scenarios-ec2|all)
      tf scenarios-ec2 output
      ;;&
    scenarios-fg|all)
      tf scenarios-fg output
      ;;&
    scenarios-cloudtrail|all)
      tf scenarios-cloudtrail output
      ;;&
    scenarios-cspm|all)
      tf scenarios-cspm output
      ;;&
    scenarios-identity|all)
      tf scenarios-identity output
      if [ "${pgo_active_directory}" == 'true' ]; then
        printf '%s\n' "ad_admin_password = $(terraform -chdir=${configs[scenarios-identity]} output -raw ad_admin_password)"
      fi
      ;;&
    scenarios-zerotrust|all)
      tf scenarios-zerotrust output
      if [ "${pgo_active_directory}" == 'true' ]; then
        printf '%s\n' "ad_admin_password = $(terraform -chdir=${configs[scenarios-zerotrust]} output -raw ad_admin_password)"
      fi
      printf '%s\n' "win_local_admin_password = $(terraform -chdir=${configs[scenarios-zerotrust]} output -raw win_local_admin_password)"
      ;;&
    scenarios-aks|all)
      tf scenarios-aks output
      ;;&
    goat|all)
      tf goat output
      ;;&
    dsm|deepsecurity|all)
      tf dsm output
      ;;&
    dsw|all)
      tf dsw output
      printf '%s\n' "public_instance_password_windows1 = $(terraform -chdir=${configs[dsw]} output -raw public_instance_password_windows1)"
      ;;&
    wsw|all)
      tf wsw output
      printf '%s\n' "public_instance_password_windows1 = $(terraform -chdir=${configs[wsw]} output -raw public_instance_password_windows1)"
      ;;&
    kind|all)
      tf kind output
      tf kind-deployments output
      ;;&
    scenarios-kind|all)
      tf scenarios-kind output
      ;;
  esac
}

#######################################
# Lists applied Terraform configurations
# Globals:
#   ONEPATH
# Arguments:
#   None
# Outputs:
#   None
#######################################
function list() {

  telemetry "list"

  # Iterate over configs keys
  for config in "${!configs[@]}"; do
    if checklock $config ; then
      printf '%s\n' "Configuration ${config} is applied"
    fi
  done
}

#######################################
# Shows a Terraform configuration state
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function state() {

  telemetry "state" $1

  case $1 in
    user|all)
      tf user state
      ;;&
    satellite|all)
      tf satellite state
      ;;&
    nw|network|all)
      tf network state
      ;;&
    ec2|instances|all)
      tf instances state
      ;;&
    testlab-cs|all)
      tf testlab-cs state
      ;;&
    eks|eks-ec2|all)
      tf eks-ec2 state
      tf eks-ec2-deployments state
      ;;&
    eks-fg|all)
      tf eks-fg state
      tf eks-fg-deployments state
      ;;&
    aks|all)
      tf aks state
      tf aks-deployments state
      ;;&
    ecs-ec2|all)
      tf ecs-ec2 state
      ;;&
    ecs-fg|all)
      tf ecs-fg state
      ;;&
    bucketscanner|all)
      tf bucketscanner state
      ;;&
    scenarios|scenarios-ec2|all)
      tf scenarios-ec2 state
      ;;&
    scenarios-fg|all)
      tf scenarios-fg state
      ;;&
    scenarios-cloudtrail|all)
      tf scenarios-cloudtrail state
      ;;&
    scenarios-cspm|all)
      tf scenarios-cspm state
      ;;&
    scenarios-identity|all)
      tf scenarios-identity state
      ;;&
    scenarios-identity|all)
      tf scenarios-identity state
      ;;&
    scenarios-aks|all)
      tf scenarios-aks state
      ;;&
    goat|all)
      tf goat state
      ;;&
    dsm|deepsecurity|all)
      tf dsm state
      ;;&
    dsw|all)
      tf dsw state
      ;;&
    wsw|all)
      tf wsw state
      ;;&
    kind|all)
      tf kind state
      tf kind-deployments state
      ;;&
    scenarios-kind|all)
      tf scenarios-kind state
      ;;
  esac
}

#######################################
# Shows a Terraform configuration full
# state
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function show() {

  telemetry "show" $1

  case $1 in
    user|all)
      tf user state
      ;;&
    satellite|all)
      tf satellite show
      ;;&
    nw|network|all)
      tf network show
      ;;&
    ec2|instances|all)
      tf instances show
      ;;&
    testlab-cs|all)
      tf testlab-cs show
      ;;&
    eks|eks-ec2|all)
      tf eks-ec2 show
      tf eks-ec2-deployments show
      ;;&
    eks-fg|all)
      tf eks-fg show
      tf eks-fg-deployments show
      ;;&
    aks|all)
      tf aks show
      tf aks-deployments show
      ;;&
    ecs-ec2|all)
      tf ecs-ec2 show
      ;;&
    ecs-fg|all)
      tf ecs-fg show
      ;;&
    bucketscanner|all)
      tf bucketscanner show
      ;;&
    scenarios|scenarios-ec2|all)
      tf scenarios-ec2 show
      ;;&
    scenarios-fg|all)
      tf scenarios-fg show
      ;;&
    scenarios-cloudtrail|all)
      tf scenarios-cloudtrail show
      ;;&
    scenarios-cspm|all)
      tf scenarios-cspm show
      ;;&
    scenarios-identity|all)
      tf scenarios-identity show
      ;;&
    scenarios-zerotrust|all)
      tf scenarios-zerotrust show
      ;;&
    scenarios-aks|all)
      tf scenarios-aks show
      ;;&
    goat|all)
      tf goat show
      ;;&
    dsm|deepsecurity|all)
      tf dsm show
      ;;&
    dsw|all)
      tf dsw show
      ;;&
    wsw|all)
      tf wsw show
      ;;&
    kind|all)
      tf kind show
      tf kind-deployments show
      ;;&
    scenarios-kind|all)
      tf scenarios-kind show
      ;;
  esac
}

#######################################
# Validates a Terraform configuration
# Globals:
#   ONEPATH
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function validate() {

  telemetry "validate" $1

  case $1 in
    user|all)
      tf user validate
      ;;&
    satellite|all)
      tf satellite validate
      ;;&
    nw|network|all)
      if [ "${pgo_vpn_gateway}" == 'true' ]; then
        if [ ! -f ${ONEPATH}/vpn-secrets.yaml ]; then
          $ONEPATH/bin/generate-secrets.sh
        fi
      fi
      tf network validate
      ;;&
    ec2|instances|all)
      tf instances validate
      ;;&
    testlab-cs|all)
      tf testlab-cs validate
      ;;&
    eks|eks-ec2|all)
      tf eks-ec2 validate
      tf eks-ec2-deployments validate
      ;;&
    eks-fg|all)
      tf eks-fg validate
      tf eks-fg-deployments validate
      ;;&
    aks|all)
      tf aks validate
      tf aks-deployments validate
      ;;&
    ecs-ec2|all)
      tf ecs-ec2 validate
      ;;&
    ecs-fg|all)
      tf ecs-fg validate
      ;;&
    bucketscanner|all)
      tf bucketscanner validate
      ;;&
    scenarios|scenarios-ec2|all)
      tf scenarios-ec2 validate
      ;;&
    scenarios-fg|all)
      tf scenarios-fg validate
      ;;&
    scenarios-cloudtrail|all)
      tf scenarios-cloudtrail validate
      ;;&
    scenarios-cspm|all)
      tf scenarios-cspm validate
      ;;&
    scenarios-identity|all)
      tf scenarios-identity validate
      ;;&
    scenarios-zerotrust|all)
      tf scenarios-zerotrust validate
      ;;&
    scenarios-aks|all)
      tf scenarios-aks validate
      ;;&
    goat|all)
      tf goat validate
      ;;&
    dsm|deepsecurity|all)
      tf dsm validate
      ;;&
    dsw|all)
      tf dsw validate
      ;;&
    wsw|all)
      tf wsw validate
      ;;&
    kind|all)
      tf kind validate
      tf kind-deployments validate
      ;;&
    scenarios-kind|all)
      tf scenarios-kind validate
      ;;
  esac
}

#######################################
# Controls Colima on Darwin
# Globals:
#   None
# Arguments:
#   enable|disable
# Outputs:
#   None
#######################################
function colima-service() {

  telemetry "colima-service" $1

  case $1 in
    enable|true)
      # brew services start colima
      colima start
      ;;
    disable|false)
      # brew services stop colima
      colima stop
      ;;
  esac
}

#######################################
# Cleanup Terraform state and modules
# Globals:
#   None
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function erase() {

  telemetry "cleanup" $1

  case $1 in
    user|all)
      tf user erase
      ;;&
    satellite|all)
      tf satellite erase
      ;;&
    nw|network|all)
      tf network erase
      ;;&
    ec2|instances|all)
      tf instances erase
      ;;&
    testlab-cs|all)
      tf testlab-cs erase
      ;;&
    eks|eks-ec2|all)
      tf eks-ec2 erase
      tf eks-ec2-deployments erase
      ;;&
    eks-fg|all)
      tf eks-fg erase
      tf eks-fg-deployments erase
      ;;&
    aks|all)
      tf aks erase
      tf aks-deployments erase
      ;;&
    ecs-ec2|all)
      tf ecs-ec2 erase
      ;;&
    ecs-fg|all)
      tf ecs-fg erase
      ;;&
    bucketscanner|all)
      tf bucketscanner erase
      ;;&
    scenarios|scenarios-ec2|all)
      tf scenarios-ec2 erase
      ;;&
    scenarios-fg|all)
      tf scenarios-fg erase
      ;;&
    scenarios-cloudtrail|all)
      tf scenarios-cloudtrail erase
      ;;&
    scenarios-cspm|all)
      tf scenarios-cspm erase
      ;;&
    scenarios-identity|all)
      tf scenarios-identity erase
      ;;&
    scenarios-zerotrust|all)
      tf scenarios-zerotrust erase
      ;;&
    scenarios-aks|all)
      tf scenarios-aks erase
      ;;&
    goat|all)
      tf goat erase
      ;;&
    dsm|deepsecurity|all)
      tf dsm erase
      ;;&
    dsw|all)
      tf dsw erase
      ;;&
    wsw|all)
      tf wsw erase
      ;;&
    kind|all)
      tf kind erase
      tf kind-deployments erase
      ;;&
    scenarios-kind|all)
      tf scenarios-kind erase
      ;;
  esac
}

#######################################
# Snapshotting configurations
#   Freeze configuration, create AMIs
#   Retrieve configuration by Tag
#   Delete frozen configuration by Tag
# Globals:
#   None
# Arguments:
#   Configuration name or all
# Outputs:
#   None
#######################################
function is_instance_stopped() {
  instance_state=$(aws ec2 describe-instances --instance-ids $1 | jq -r '.Reservations[0].Instances[0].State.Name')
  if [ "${instance_state}" == "stopped" ]; then
    return
  fi
  false
}

function freeze_configuration() {
  key_desc="Snapshot Name"
  datestr=$(date '+%Y%m%d')
  snapshot_name=${datestr}
  read -p "${key_desc} [${snapshot_name}]: " TEMP
  if [[ ! -z "${TEMP}" ]]; then
    snapshot_name=${TEMP}
  fi
  if [[ "${snapshot_name}" =~ ^[0-9a-z\-]+$ && ${#snapshot_name} -le 20 ]]; then
    printf '%s\n' "Tagging AMIs with Snapshot Name=${snapshot_name}"
  else
    printf '%s\n' "Error: Invalid ${key_desc} input."
    exit 0
  fi

  configuration_name=$1
  instance_ids=$(aws ec2 describe-instances \
      --filters "Name=instance-state-name,Values=running,stopped" \
                "Name=tag:Configuration,Values=${configuration_name}" \
                "Name=tag:Environment,Values=${environment_name}" \
      --query "Reservations[*].Instances[*].InstanceId" \
      --output text)

  unset AWS_ACCESS_KEY_ID
  unset AWS_SECRET_ACCESS_KEY
  for instance_id in ${instance_ids}; do
    # Get Instance IDs to snapshot
    instance_name=$(aws ec2 describe-instances --instance-ids ${instance_id} | jq -r '.Reservations[0].Instances[0].Tags[] | select(.Key=="Name") | .Value')

    # Filter out DDI, SG
    if [[ ! "$instance_name" == *"ddi-va"* && ! "$instance_name" == *"sg-va"* ]]; then
      aws ec2 stop-instances --instance-ids ${instance_id}
      i=1
      while [ $i -le 60 ]; do
        if is_instance_stopped ${instance_id}; then
          break
        fi
        printf '%s\n' "Waiting for instance ${instance_id} to be in stopped state"
        sleep 5
      done

      printf '%s\n' "Creating AMI of ${instance_id} with name ${instance_name}"
      aws ec2 create-image \
        --instance-id ${instance_id} \
        --name "${configuration_name}-${instance_name}-${snapshot_name}" \
        --tag-specifications "ResourceType=image,Tags=[{Key=Environment,Value=${environment_name}},
                                                        {Key=Product,Value=playground-one},
                                                        {Key=Configuration,Value=${configuration_name}},
                                                        {Key=Name,Value=${configuration_name}-${snapshot_name}},
                                                        {Key=Created,Value=${datestr}},
                                                        {Key=InstanceName,Value=${instance_name}}]"
    else
      printf '%s\n' "Skipping instance ${instance_id}"
    fi
  done
}

function freeze_retrieve() {
  key_desc="Snapshot Name"
  snapshot_name=""
  read -p "${key_desc} [${snapshot_name}]: " TEMP
  if [[ ! -z "${TEMP}" ]]; then
    snapshot_name=${TEMP}
  fi
  if [[ "${snapshot_name}" =~ ^[0-9a-z\-]+$ && ${#snapshot_name} -le 20 ]]; then
    printf '%s\n' "Retrieveing AMIs with Snapshot Name=${snapshot_name}"
  else
    printf '%s\n' "Error: Invalid ${key_desc} input."
    exit 0
  fi

  configuration_name=$1
  ami_list=$(aws ec2 describe-images \
    --filters "Name=tag:Configuration,Values=${configuration_name}" \
              "Name=tag:Environment,Values=${environment_name}" \
              "Name=tag:Name,Values=${configuration_name}-${snapshot_name}" | \
    jq -r '.Images[] | (.Tags[] | select(.Key=="InstanceName") | .Value) + "=" + .ImageId' | \
    sort)
}

function freeze_delete() {
  key_desc="Snapshot Name"
  snapshot_name=""
  read -p "${key_desc} [${snapshot_name}]: " TEMP
  if [[ ! -z "${TEMP}" ]]; then
    snapshot_name=${TEMP}
  fi
  if [[ "${snapshot_name}" =~ ^[0-9a-z\-]+$ && ${#snapshot_name} -le 20 ]]; then
    printf '%s\n' "Deleting AMIs with Snapshot Name=${snapshot_name}"
  else
    printf '%s\n' "Error: Invalid ${key_desc} input."
    exit 0
  fi

  unset AWS_ACCESS_KEY_ID
  unset AWS_SECRET_ACCESS_KEY
  configuration_name=$1
  ami_prefix="${configuration_name}-${environment_name}-"

  # Get a list of AMIs owned by the current AWS account that start with the given prefix
  ami_ids=$(aws ec2 describe-images --owners self \
      --filters "Name=name,Values=$ami_prefix*" \
                "Name=tag:Name,Values=${configuration_name}-${snapshot_name}" \
      --query "Images[*].ImageId" --output text)

  # Check if any AMIs were found
  if [ -z "$ami_ids" ]; then
      printf '%s\n' "No AMIs found with prefix '$ami_prefix'."
      exit 0
  fi

  printf '\n%s\n' "Following AMIs found with prefix '$ami_prefix'."
  printf '%s\n' $ami_ids
  printf '\n%s\n' "${bold}Do you really want to delete?${normal}"
  printf '%s\n' "  Only 'yes' will be accepted to approve."
  read -p "${bold}Enter a value: ${normal}" TEMP

  if [[ "${TEMP}" == "yes" ]]; then
    # Loop through each AMI and delete it along with its associated snapshots
    for ami_id in $ami_ids; do
        printf '%s\n' "Processing AMI: $ami_id"

        # Get snapshot IDs associated with the AMI
        snapshot_ids=$(aws ec2 describe-images --image-ids "$ami_id" \
            --query "Images[0].BlockDeviceMappings[*].Ebs.SnapshotId" --output text)

        # Deregister the AMI
        printf '%s\n' "Deregistering AMI: $ami_id"
        aws ec2 deregister-image --image-id "$ami_id"

        # Delete associated snapshots
        for snapshot_id in $snapshot_ids; do
            printf '%s\n' "Deleting Snapshot: $snapshot_id"
            aws ec2 delete-snapshot --snapshot-id "$snapshot_id"
        done
    done

    printf '%s\n' "All matching AMIs and their snapshots have been deleted successfully."
  else
    printf '\n%s\n' "${bold}Error:${normal} error asking for approval: interrupted"
  fi
}

function freeze_list_tags() {

  configuration_name=$1
  ami_prefix="${configuration_name}-${environment_name}-"
  tag_list=$(aws ec2 describe-images \
    --owners self \
    --filters "Name=name,Values=$ami_prefix*" \
    | jq -r '.Images[].Tags[] | select(.Key=="Name") | .Value' | sort | uniq)
  
  if [ -z "${tag_list}" ]; then
    printf '%s\n' "No available Tags for Configuration ${configuration_name}"
  else
    printf '%s\n%s\n' "Available Tags for Configuration ${configuration_name}:" "${tag_list}"
  fi
}

function snapshot_freeze() {

  telemetry "snapshot_freeze" $1

  case $1 in
    nw|network|all)
      freeze_configuration nw
      ;;&
    ec2|instances|all)
      printf '%s\n' "Not implemented yet"
      ;;&
    testlab-cs|all)
      freeze_configuration testlab-cs
      ;;&
  esac
}

function snapshot_retrieve() {

  telemetry "snapshot_retrieve" $1

  case $1 in
    nw|network|all)
      freeze_retrieve nw

      ami_active_directory_dc=""
      ami_active_directory_ca=""
      ami_service_gateway=""
      ami_deep_discovery_inspector=""
      for ami in ${ami_list}; do
        printf '%s\n' $ami
        if [[ $ami =~ .*-dc.* ]]; then
          ami_active_directory_dc=${ami#*=}
        fi
        if [[ $ami =~ .*-ca.* ]]; then
          ami_active_directory_ca=${ami#*=}
        fi
        if [[ $ami =~ .*-sg.* ]]; then
          ami_service_gateway=${ami#*=}
        fi
        if [[ $ami =~ .*-ddi.* ]]; then
          ami_deep_discovery_inspector=${ami#*=}
        fi
      done

      if [ -z "${ami_active_directory_dc}" ]; then
        yq -i 'del(.services.aws.configuration.network.ami-active-directory-dc)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_active_directory_dc} \
          yq -i '.services.aws.configuration.network.ami-active-directory-dc = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_active_directory_ca}" ]; then
        yq -i 'del(.services.aws.configuration.network.ami-active-directory-ca)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_active_directory_ca} \
          yq -i '.services.aws.configuration.network.ami-active-directory-ca = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_service_gateway}" ]; then
        yq -i 'del(.services.aws.configuration.network.ami-service-gateway)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_service_gateway} \
          yq -i '.services.aws.configuration.network.ami-service-gateway = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_deep_discovery_inspector}" ]; then
        yq -i 'del(.services.aws.configuration.network.ami-deep-discovery-inspector)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_deep_discovery_inspector} \
          yq -i '.services.aws.configuration.network.ami-deep-discovery-inspector = env(target_val)' ${ONEPATH}/config.yaml
      fi

      sed -i "/^ami_active_directory_dc = .*/c  ami_active_directory_dc = \"${ami_active_directory_dc}\"" ${configs[network]}/terraform.tfvars
      sed -i "/^ami_active_directory_ca = .*/c  ami_active_directory_ca = \"${ami_active_directory_ca}\"" ${configs[network]}/terraform.tfvars
      sed -i "/^ami_service_gateway = .*/c  ami_service_gateway = \"${ami_service_gateway}\"" ${configs[network]}/terraform.tfvars
      sed -i "/^ami_deep_discovery_inspector = .*/c  ami_deep_discovery_inspector = \"${ami_deep_discovery_inspector}\"" ${configs[network]}/terraform.tfvars

      printf '%s\n' "${configs[network]}/terraform.tfvars patched."
      ;;&
    ec2|instances|all)
      printf '%s\n' "Not implemented yet"
      ;;&
    testlab-cs|all)
      freeze_retrieve testlab-cs
      
      ami_apex_one_server=""
      ami_apex_one_central=""
      ami_windows_client="["
      ami_bastion=""
      ami_dsm=""
      ami_postgresql=""
      for ami in ${ami_list}; do
        printf '%s\n' $ami
        if [[ $ami =~ .*apex-one-central.* ]]; then
          ami_apex_one_central=${ami#*=}
        fi
        if [[ $ami =~ .*apex-one-server.* ]]; then
          ami_apex_one_server=${ami#*=}
        fi
        if [[ $ami =~ .*windows-client.* ]]; then
          ami_windows_client+="\"${ami#*=}\","
        fi
        if [[ $ami =~ .*bastion.* ]]; then
          ami_bastion=${ami#*=}
        fi
        if [[ $ami =~ .*dsm.* ]]; then
          ami_dsm=${ami#*=}
        fi
        if [[ $ami =~ .*postgresql.* ]]; then
          ami_postgresql=${ami#*=}
        fi
      done
      ami_windows_client="${ami_windows_client%,}]"

      if [ -z "${ami_apex_one_server}" ]; then
        yq -i 'del(.services.aws.configuration.testlab-cs.ami-apex-one-server)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_apex_one_server} \
          yq -i '.services.aws.configuration.testlab-cs.ami-apex-one-server = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_apex_one_central}" ]; then
        yq -i 'del(.services.aws.configuration.testlab-cs.ami-apex-one-central)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_apex_one_central} \
          yq -i '.services.aws.configuration.testlab-cs.ami-apex-one-central = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ "${ami_windows_client}" == '[]' ]; then
        yq -i 'del(.services.aws.configuration.testlab-cs.ami-windows-client)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_windows_client} \
          yq -i '.services.aws.configuration.testlab-cs.ami-windows-client = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_bastion}" ]; then
        yq -i 'del(.services.aws.configuration.testlab-cs.ami-bastion)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_bastion} \
          yq -i '.services.aws.configuration.testlab-cs.ami-bastion = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_dsm}" ]; then
        yq -i 'del(.services.aws.configuration.testlab-cs.ami-dsm)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_dsm} \
          yq -i '.services.aws.configuration.testlab-cs.ami-dsm = env(target_val)' ${ONEPATH}/config.yaml
      fi
      if [ -z "${ami_postgresql}" ]; then
        yq -i 'del(.services.aws.configuration.testlab-cs.ami-postgresql)' ${ONEPATH}/config.yaml
      else
        target_val=${ami_postgresql} \
          yq -i '.services.aws.configuration.testlab-cs.ami-postgresql = env(target_val)' ${ONEPATH}/config.yaml
      fi

      sed -i "/^ami_apex_one_server = .*/c  ami_apex_one_server = \"${ami_apex_one_server}\"" ${configs[testlab-cs]}/terraform.tfvars
      sed -i "/^ami_apex_one_central = .*/c  ami_apex_one_central = \"${ami_apex_one_central}\"" ${configs[testlab-cs]}/terraform.tfvars
      sed -i "/^ami_windows_client = .*/c  ami_windows_client = ${ami_windows_client}" ${configs[testlab-cs]}/terraform.tfvars
      sed -i "/^ami_bastion = .*/c  ami_bastion = \"${ami_bastion}\"" ${configs[testlab-cs]}/terraform.tfvars
      sed -i "/^ami_dsm = .*/c  ami_dsm = \"${ami_dsm}\"" ${configs[testlab-cs]}/terraform.tfvars
      sed -i "/^ami_postgresql = .*/c  ami_postgresql = \"${ami_postgresql}\"" ${configs[testlab-cs]}/terraform.tfvars

      printf '%s\n' "${configs[testlab-cs]}/terraform.tfvars patched."

      ;;&
  esac
}

function snapshot_delete() {

  telemetry "snapshot_delete" $1

  case $1 in
    nw|network|all)
      freeze_delete nw
      ;;&
    ec2|instances|all)
      printf '%s\n' "Not implemented yet"
      ;;&
    testlab-cs|all)
      freeze_delete testlab-cs
      ;;&
  esac
}

function snapshot_list() {

  telemetry "snapshot_list" $1

  case $1 in
    nw|network|all)
      freeze_list_tags nw
      ;;&
    ec2|instances|all)
      printf '%s\n' "Not implemented yet"
      ;;&
    testlab-cs|all)
      freeze_list_tags testlab-cs
      ;;&
  esac
}

#######################################
# Update Playground One and components
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
function update() {
  cd ${ONEPATH}
  bin/bootstrap.sh
}

#######################################
# Update Playground One and components
# Globals:
#   None
# Arguments:
#   None
# Outputs:
#   None
#######################################
# function update-v1cs() {

#   printf '%s\n' "Getting latest Vision One Container Security"
#   mkdir -p ${ONEPATH}/.packages
#   cd ${ONEPATH}/.packages
#   rm -rf cloudone-container-security-helm-master
#   curl -Ls https://github.com/trendmicro/cloudone-container-security-helm/archive/master.tar.gz -o master.tar.gz
#   tar xfz master.tar.gz
# }

function helpcmd() {

  printf '%s\n' "Usage: pgo -<command> <configuration> ..."
  printf '%s\n' ""
  printf '%s\n' "The available commands for execution are listed below."
  printf '%s\n' "The primary workflow commands are given first, followed by"
  printf '%s\n' "less common or more advanced commands."
  printf '%s\n' ""
  printf '%s\n' "Main commands:"
  printf '%s\n' "  -c --config    Set/update Playground One main configuration"
  printf '%s\n' "  -i --init      Prepare a configuration for other commands"
  printf '%s\n' "  -a --apply     Create or update a configuration"
  printf '%s\n' "  -l --list      List applied configurations"
  printf '%s\n' "  -d --destroy   Destroy previously-created configuration"
  printf '%s\n' "  -o --output    Show output values"
  printf '%s\n' "  -s --state     Show the current state"
  printf '%s\n' "  -E --erase     Cleanup Terraform state"
  printf '%s\n' "  -h --help      Show this help"
  printf '%s\n' ""
  printf '%s\n' "Snapshotting configuration commands:"
  printf '%s\n' "  -F --snapshot-freeze    Freeze and tag configuration, create AMIs"
  printf '%s\n' "  -R --snapshot-retrieve  Retrieve configuration by Tag"
  printf '%s\n' "  -D --snapshot-delete    Delete frozen configuration by Tag"
  printf '%s\n' "  -L --snapshot-list-tags List Tags for configuration"
  printf '%s\n' ""
  printf '%s\n' "Other commands:"
  printf '%s\n' "  -S --show      Show advanced state"
  printf '%s\n' "  -u --updateip  Update access IP(s)"
  printf '%s\n' "  -U --update    Update Playground One and components"
  printf '%s\n' "  -v --validate  Check whether the configuration is valid"
  printf '%s\n' "  -p --plan      Plan apply and destroy"
  printf '%s\n' ""
  printf '%s\n' "Available configurations:"
  printf '%s\n' "  user                 PGO User configuration"
  printf '%s\n' "  satellite            PGO Satellite configuration"
  printf '%s\n' "  network              Network configuration"
  printf '%s\n' "  instances            EC2 configuration"
  printf '%s\n' "  testlab-cs           Testlab-CS configuration"
  printf '%s\n' "  eks-ec2              EKS configuration"
  printf '%s\n' "  eks-fg               EKS configuration"
  printf '%s\n' "  ecs-ec2              ECS configuration"
  printf '%s\n' "  ecs-fg               ECS configuration"
  printf '%s\n' "  bucketscanner        S3 Bucket Scanner configuration"
  printf '%s\n' "  kind                 Kind configuration"
  printf '%s\n' "  scenarios-ec2        Scenario configuration"
  printf '%s\n' "  scenarios-fg         Scenario configuration"
  printf '%s\n' "  scenarios-cloudtrail Scenario configuration"
  printf '%s\n' "  scenarios-cspm       Scenario configuration"
  printf '%s\n' "  scenarios-identity   Scenario configuration"
  printf '%s\n' "  scenarios-zerotrust  Scenario configuration"
  printf '%s\n' "  scenarios-kind       Scenario configuration"
  printf '%s\n' "  scenarios-aks        Scenario configuration"
  printf '%s\n' "  dsm                  Deep Security configuration"
  printf '%s\n' "  dsw                  Deep Security Workload configuration"
  printf '%s\n' "  wsw                  Workload Security Workload configuration"
  printf '%s\n' "  aks                  AKS configuration"
  printf '%s\n' "  all                  All configurations"
  printf '%s\n' ""
  printf '%s\n' "Examples:"
  printf '%s\n' "  pgo --apply nw"
  printf '%s\n' "  pgo --state all"
}

#######################################
# Main:
#######################################
[ -z "$1" ] && helpcmd

if [ -f ${ONEPATH}/config.yaml ]; then
  get_config
fi

# Check if we're using a PGO user
export AWS_ACCESS_KEY_ID=${aws_pgo_user_access_key}
export AWS_SECRET_ACCESS_KEY=${aws_pgo_user_secret_key}
if ${aws_pgo_user_enabled} ; then
  printf '%s\n' "Using PDO User Access Key ID: ...${aws_pgo_user_access_key:(-4)}"
else
  printf '%s\n' "Using System Access Key or Instance Role"
fi

opts_short=pci:t:a:ld:o:s:S:v:uhE:F:R:D:L:U
opts_long=plan,config,init:,tfvars:,apply:,list,destroy:,output:,state:,show:,validate:,updateip,help,erase:,snapshot-freeze:,snapshot-retrieve:,snapshot-delete:,snapshot-list-tags:,update

if is_darwin; then
  TEMP=$(/opt/homebrew/opt/gnu-getopt/bin/getopt -o ${opts_short}C: --long ${opts_long},colima: -- "$@")

  if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

  eval set -- "$TEMP"
else
  TEMP=$(getopt -o ${opts_short} --long ${opts_long} -- "$@")
  if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi

  eval set -- "$TEMP"
fi

# Check if IP address changed
configured_cidr=${pgo_access_ip//[\[\]\"]/}
current_cidr=$(curl -s ifconfig.me && echo)'/32'
if [[ ${configured_cidr} != *"$current_cidr"* ]] ; then
  printf '%s\n' "${bold}${red}!!! Access IP mismatch !!!${normal}"
  sleep 3
fi

# Check for a valid configuration
if [ "$2" != "--" ] && [ "$2" != "" ]; then
  [ "${configs[$2]+abc}" ] && printf '%s\n' "Configuration name: ${2}" || (printf '%s\n' "${bold}${red}Configuration ${2} does not exist.${normal}"; exit 0;)
fi

while true; do
  case "$1" in
    -p | --plan ) dryrun=True; shift 1 ;;
    -c | --config ) pgo-configure; break ;;
    -i | --init ) init $2; shift 2 ;;
    -t | --tfvars ) init $2 tfvars; shift 2 ;;
    -a | --apply ) apply $2; shift 2 ;;
    -l | --list ) list; break ;;
    -d | --destroy ) destroy $2; shift 2 ;;
    -o | --output ) output $2; shift 2 ;;
    -s | --state ) state $2; shift 2 ;;
    -S | --show ) show $2; shift 2 ;;
    -v | --validate ) validate $2; shift 2 ;;
    -u | --updateip ) update_ip; break ;;
    -h | --help ) helpcmd; break ;;
    -C | --colima ) colima-service $2; shift 2 ;;
    -E | --erase ) erase $2; shift 2 ;;

    -F | --snapshot-freeze ) snapshot_freeze $2; shift 2 ;;
    -R | --snapshot-retrieve ) snapshot_retrieve $2; shift 2 ;;
    -D | --snapshot-delete ) snapshot_delete $2; shift 2 ;;
    -L | --snapshot-list-tags ) snapshot_list $2; shift 2 ;;

    -U | --update ) update; break ;;
    # -C | --updatev1cs ) update-v1cs; break ;;
    -- ) shift; break ;;
    * ) break ;;
  esac
done
